#Lesson 1 : NOTES

- 'b' lowers a note by one half note step
- '#' raises a note by one half note step
To test whether an arbitrary string is valid, we can use notes.is_valid_note(str)
Examples of valid notes:
notes.is_valid_note("C")
  True
notes.is_valid_note("D#")
  True
notes.is_valid_notes("Fbb")
  True
Examples of invalid notes:
notes.is_valid_note("c") 
  False #note must be capitalized
notes.is_valid_note("D #")
  False #cant have space in between note and sharp
notes.is_valid_note("E-b")
  False
Examples of surprisingly valid notes:
notes.is_valid_note("C#####bb")
  True
notes.is_valid_note("C#bb##bb##bb#")
  True
Basically, mingus can take any number of accidentals whether wise to do so or not. Only rule is that it has to follow the correct format
Once accidentals get messy however, we can use remove_redundant_accidentals(note)
Examples:
notes.remove_redundant_accidentals("C##b")
  'C#'
notes.remove_redundant_accidentals("C#b#bb#b##bb"
  'C'
  
#NOTES AS INTEGERS
sometimes it is easier to work with notes as integers in range(0,12)
- Is possible with the functions notes.note_to_int(str) and notes.int_to_note(int)

#note to integer
notes.note_to_int("C")
  0
notes.note_to_int("B")
  11
notes.note_to_int("Cb")
  11
notes.note_to_int("C#")
  1
notes.note_to_int("Db")
  1
There is also a function to see if two notes are enharmonic 
- notes.is_enharmonic(note1,note2)

#integer to note

notes.int_to_note(0)
  "C"
notes.int_to_note(1)
  "C#"
notes.int_to_note(2)
  "D"
notes.int_to_note(3)
  "D#"
  
#NOTES AUGMENTED

notes.augment("C")
  "C#"
notes.augment("Cb")
  "C"
notes.augment("C#")
  "C##"
notes.augment("B")
  "B#"
  
#NOTES DIMINSHED

notes.diminish("C")
  "Cb"
notes.diminish("C#")
  "C"
notes.diminish("Cb")
  "Cbb"
notes.diminish("B#")
  "B"
  
 #MINOR AND MAJOR CONVERSIONS (keys --> relative major/minor)
 THIS DOES NOT WORK, DONT USE THIS


ALL OF TUTORIAL TWO DOES NOT WORK
#TUTORIAL 3
Natural diatonic intervals
taking the natural unison, second, third fourth, fifth, sixth, or seventh of a certain note in a CERTAIN KEY.

for example
intervals.second("C","C")
  taking the second note starting on C in the key of C --> D
intervals.second("E","C")
  taking the second note starting on E in the key of C --> F
intervals.second("E","D") 
  taking the second note starting on E in the key of D major --> F#

Absolute intervals
intervals.minor_second("C")
  "Db"
 intervals.major_sixth("C")
  "A"
*major_fifth and major_fourth are better known as perfect_fifth and perfect_fourth

Interval recognization

intervals.determine("C","E"):
  "major third"
intervals.determine("C","B"):
  "major seventh"
intervals.determine("Gbb","Ab")
  "augmented second"
  
 Measuring:
 
 interval.measure("C","D")
  2
 interval.measure("D","C")
  10

#TUTORIAL 4
triads are chords made of three notes

function to make chords:
chords.triad(note,key)
chords.triad("E","C")
  ["E","G","B"] --> triad starting on E, in the key of C
chord.triad("E","E")
  ["E", "G#", "B"] --> triad starting on E, in the key of E
chord.triad("E","F")
  ["E","G","Bb"] --> triad starting on E in the key of F
  
We may also request ALL the triads in A CERTAIN KEY with chords.triads(key):
chords.triads("C")

Can request absolute Triads:
chords.major_triad("C")
  ["C","E","G"]
chords.minor_triad("C")
   ["C","Eb","G"]
 chords.diminished_triad("C")
    ["C","Eb","Gb"]
chords.suspended_triad("C")
["C", "F", "G"] --> a sus4 chord (ommiting the major/minor third for a perfect fourth, we can also replace it for a major second (sus2)
 #NATURAL DIATONIC SEVENTHS
 actual dominant sevenths use the fifth note as its root
 https://www.libertyparkmusic.com/dominant-diminished-seventh-chords/#:~:text=A%20dominant%20seventh%20chord%20consists,(or%20minor)%20is%20G%2DB%2DD%2DF.
 dominant sevenths (starts on fifth note) - made of a major third, perfect fifth, and minor seventh (all with respect to the root)
 diminished seventh (starts on root) - all notes seperated by a minor third
  
  chords.seventh("C", "C")
["C", "E", "G", "B"]
>>> chords.seventh("D", "C")
["D", "F", "A", "C"]
>>> chords.seventh("E", "C")
["E", "G", "B", "D"]

#absolute sevenths
chords.diminished_seventh("C")
["C", "Eb", "Gb", "Bbb"]
chords.augmented_major_seventh("C")
["C", "E", "G#", "B"]
>>> chords.augmented_minor_seventh("C")
["C", "E", "G#", "Bb"]

#CHORDS BY HARMONIC FUNCTION, you can also use roman numals tho


chords.tonic("C") OR chords.I("C") (bc tonic is fist note)
["C", "E", "G"]
>>> chords.supertonic("C")
["D", "F", "A"]
>>> chords.mediant("C")
["E", "G", "B"]
>>> chords.subdominant("C") OR chords.IV("C")
["F", "A", "C"]
>>> chords.dominant("C")
["G", "B", "D"]
>>> chords.submediant("C")
["A", "C", "E"]

DOMINANT SEVENTH
chords.V7('C')
['G', 'B', 'D', 'F']

#you can also play around with modes. 
ionian, dorian, phrygian etc. For example, c dorian would start on c (but c is the second note of the scale), you would use B major (a whole note below C's) key signature 

#INVERSIONS HERE TOO
chords.first_inversion(["C", "E", "G"])
["E", "G", "C"] #basically just starting on the second note
chords.second_inversion(["C", "E", "G"]) #just starting on the third day
["G", "C", "E"]

#can recognize chords
chords.determine(["C", "E", "G"])
['C major triad']

#Tutorial 5
MODES:
scales.Dorin("D")
["D", "E", "F", "G", "A", "B", "C"] #d is the second note of c major scale, so we start on , but use the c major key
scales.Aolian("A")
["A", "B", "C", "D", "E", "F", "G"]
#has melodic and harmonic scales
scales.HarmonicMinor("A")
["A", "B", "C", "D", "E", "F", "G#"]
 scales.MelodicMinor("A")
["A", "B", "C", "D", "E", "F#", "G#"]

#TUTORIAL 6
in mingus, note values are represented by floating point numbers
- a quarter note is 4, because it is 1/4 note
- an eight is 8, because 1/8
- sixteenthh is 16, etc. 
Things get more complicated when we want more complex rhythms. 

value.whole
  1
value.eight
  8
value.sixteenth
  16
  MAKING DOTTED NOTES
 - a dot adds half the duration of the note, a second dot adds half of whatever was added before, etc. \
 value. dots(value.eight)
  5.33333333
 A dotted eighth note has the length of an eighth note plus half an eighth note. 1/8 + 1/16 = 3/16 = 1 / 16 / 3. So 16/3 is the number we are looking for.
value.dots(value.eight,2)
4.5714285714285712
An eigth note with two dots. so we add 1/8 + 1/16 + 1/32. which is 7/32. but we the do 1/(7/32) to flip the fraction, and this is our answer
  MAKING TUPLETS
 - some tuplets have predfined ratios, triplet(3:2), and quintuplet (5:4)
 examples:
 value.triplet(value.eight)
 12.0 --> ratio of 12:8 is simplified to (3:2)
 value.quintuplet(value.eight)
 10.0 --> the ratio of 10:8 is simplified to (5:4)
 value.septuplet(value.eighth)
 14.0 --> ratio of 14:8 can be simplified to (7:4) which is the usual septuplet ratio
 value.septuplet(value.eighth, False)
 7.0 --> this gives us a ratio of 7:8 (less common septuplet ratio)
 
  ADDING AND SUBTRACTING NOTE VALUES
  value.add(value.eight,value.quarter)
  2.666666666 ----> ADDING 1/8 + 1/4, then taking the reciprocal
  value.add(value.eight,value.eight)
  4.0 --> gives  us one quarter
  value.subtract(2.666666666666666666666666,8)
  4.0 --> we addded a dotted quarter to and eight, which gave us a quarter
#Meters!!
review: simple time (when each beat is divided into twos). compound time (when each beat is divided into threes)
basically if the numerator is 2,3,4 it is simple time, compound is when the numerator is 6,9,12

simple meters
- we may use a function to check if a time signature is valid or not
meter.is_valid((4, 4))
True
>>> meter.is_valid((4, 5))
False
>>> meter.is_valid((5, 4))
True
constants:
meter.common_time
(4, 4)
>>> meter.cut_time
(2, 2)

 #TUTORIAL 7

Functions to chores
 [chords.I("C"), chords.IV("C"), chords.V7("C")]
[chords.I("F"), chords.IV("F"), chords.V7("F")]
^^not very efficient
More efficient:
progression = ["I", "IV", "V7"]
progressions.to_chords(progression, "C")
progressions.to_chords(progression, "F")
 
 #determining chords
 a = progressions.to_chords(["I", "bIV", "VIIdim7"])
>>> a
[['C', 'E', 'G'], ['Fb', 'Ab', 'Cb'], ['B', 'D', 'F', 'Ab']]
>>> progressions.determine(a, "C")
[['tonic'], ['minor subdominant'], ['subtonic diminished seventh']]
>>> progressions.determine(a, "C", True)
[['I'], ['bIV'], ['viidim7']]
 
 #TUTORIAL 1 - the note CLASS
 defining notes:
 Note("C")
'C-4'
>>> Note("C", 4)
'C-4'
>>> Note("C", 5)
'C-5'
>>> Note("C-3")
'C-3'
>>> n = Note()
>>> n.set_note("C", 5)
>>> n
'C-5'
 
 - the note class has certain attrivutes which are accessible from outside. These include name, octave, and dynamics
 The note class note->integer function  may be better when working with octaves
 int(Note("C", 4))
48
>>> int(Note("Cb", 4))
47
>>> int(Note("B", 4))
59
Integer to note converter
c = Note()
c.from_int(12)
  'C-1'
METHODS OF THE NOTE CLASS

Octaves:
a = Note("A",5)
a.octave_up()
  'A-6'
a.octave_down()
  'A-5'
a.change_octave(+2)
  'a-5'

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
